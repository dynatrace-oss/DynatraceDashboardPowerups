"use strict";
/*
 * Copyright 2019 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const PlatformConstants_1 = require("../PlatformConstants");
const TimestampProvider_1 = require("../provider/TimestampProvider");
const StatusRequestImpl_1 = require("./StatusRequestImpl");
class BeaconSenderImpl {
    constructor(openKit, cache, config) {
        this.openKit = openKit;
        this.cache = cache;
        this.timestampProvider = TimestampProvider_1.defaultTimestampProvider;
        this.okServerId = PlatformConstants_1.defaultServerId;
        this.isShutdown = false;
        this.initialized = false;
        this.flushing = false;
        this.appId = config.applicationId;
        this.beaconUrl = config.beaconURL;
        this.channel = config.communicationChannel;
        this.sendingStrategies = config.sendingStrategies;
        this.logger = config.loggerFactory.createLogger('BeaconSender');
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug('init');
            const response = yield this.channel.sendStatusRequest(this.beaconUrl, StatusRequestImpl_1.StatusRequestImpl.create(this.appId, this.okServerId));
            if (response.valid) {
                this.initialized = true;
                this.okServerId = response.serverId === undefined ? PlatformConstants_1.defaultServerId : response.serverId;
                this.cache.getEntriesCopy().forEach((entry) => entry.communicationState.setServerId(this.okServerId));
                this.sendingStrategies.forEach((strategy) => strategy.init(this, this.cache));
            }
            this.openKit.notifyInitialized(response.valid);
        });
    }
    sessionAdded(entry) {
        entry.communicationState.setServerId(this.okServerId);
        this.sendingStrategies.forEach((strategy) => strategy.entryAdded(entry));
    }
    isInitialized() {
        return this.initialized;
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isShutdown) {
                return;
            }
            this.isShutdown = true;
            this.logger.debug('shutdown');
            // Close all sessions
            this.cache.getEntriesCopy().forEach((entry) => entry.session.end());
            for (const strategy of this.sendingStrategies) {
                yield strategy.shutdown();
            }
        });
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.flushing) {
                return;
            }
            this.flushing = true;
            if (this.initialized) {
                yield this.sendNewSessionRequests(false);
                yield this.sendPayloadData();
                yield this.finishSessions();
            }
            this.flushing = false;
        });
    }
    flushImmediate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initialized) {
                yield this.sendNewSessionRequests(true);
                yield this.sendPayloadData();
                yield this.finishSessions();
            }
        });
    }
    sendNewSessionRequests(immediate) {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = this.cache.getAllUninitializedSessions();
            if (immediate) {
                for (const entry of entries) {
                    entry.communicationState.setServerId(this.okServerId);
                    entry.communicationState.setServerIdLocked();
                    entry.initialized = true;
                }
            }
            else {
                for (const entry of entries) {
                    yield this.sendNewSessionRequest(entry);
                }
            }
        });
    }
    sendNewSessionRequest(entry) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.channel.sendNewSessionRequest(this.beaconUrl, StatusRequestImpl_1.StatusRequestImpl.create(this.appId, entry.communicationState.serverId));
            if (response.valid) {
                entry.communicationState.updateFromResponse(response);
                entry.communicationState.setServerIdLocked();
                entry.initialized = true;
            }
        });
    }
    finishSessions() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = this.cache.getAllClosedSessions();
            for (const entry of entries) {
                yield this.sendPayload(entry);
                this.cache.unregister(entry);
            }
        });
    }
    sendPayloadData() {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = this.cache.getAllInitializedSessions();
            for (const entry of entries) {
                yield this.sendPayload(entry);
            }
        });
    }
    sendPayload(entry) {
        return __awaiter(this, void 0, void 0, function* () {
            let payload;
            // tslint:disable-next-line
            while (payload = entry.builder.getNextPayload(entry.prefix, this.timestampProvider.getCurrentTimestamp())) {
                const request = StatusRequestImpl_1.StatusRequestImpl.create(this.appId, entry.communicationState.serverId);
                const response = yield this.channel.sendPayloadData(this.beaconUrl, request, payload);
                entry.communicationState.updateFromResponse(response);
            }
        });
    }
}
exports.BeaconSenderImpl = BeaconSenderImpl;
//# sourceMappingURL=BeaconSender.js.map