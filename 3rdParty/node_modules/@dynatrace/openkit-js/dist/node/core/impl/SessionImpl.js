"use strict";
/*
 * Copyright 2019 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LoggingUtils_1 = require("../logging/LoggingUtils");
const TimestampProvider_1 = require("../provider/TimestampProvider");
const Utils_1 = require("../utils/Utils");
const ActionImpl_1 = require("./ActionImpl");
const NullAction_1 = require("./null/NullAction");
const NullWebRequestTracer_1 = require("./null/NullWebRequestTracer");
const PayloadBuilderHelper_1 = require("./PayloadBuilderHelper");
const WebRequestTracerImpl_1 = require("./WebRequestTracerImpl");
class SessionImpl {
    constructor(sessionId, payloadBuilder, sessionStartTime, config, timestampProvider = TimestampProvider_1.defaultTimestampProvider) {
        this.sessionId = sessionId;
        this.config = config;
        this.openActions = [];
        this._isShutdown = false;
        this.sessionId = sessionId;
        this.payloadData = new PayloadBuilderHelper_1.PayloadBuilderHelper(payloadBuilder, sessionStartTime, timestampProvider);
        this.payloadData.startSession();
        this.logger = config.loggerFactory.createLogger(`SessionImpl (sessionId=${this.sessionId})`);
        this.logger.debug('created');
    }
    /**
     * @inheritDoc
     */
    end() {
        if (this._isShutdown) {
            // We only send the end-session event if the user enabled monitoring.
            return;
        }
        this._isShutdown = true;
        this.logger.debug('end');
        if (this.config.dataCollectionLevel === 0 /* Off */) {
            return;
        }
        // If DCL = Off => no actions are spawned anyway
        this.openActions.splice(0).forEach((action) => action.leaveAction());
        this.payloadData.endSession();
    }
    /**
     * @inheritDoc
     */
    identifyUser(userTag) {
        // Only capture userTag if we track everything.
        if (this.isShutdown() || this.config.dataCollectionLevel !== 2 /* UserBehavior */) {
            return;
        }
        // Only allow non-empty strings as userTag
        if (typeof userTag !== 'string' || userTag.length === 0) {
            LoggingUtils_1.validationFailed(this.logger, 'identifyUser', 'userTag must be a non empty string');
            return;
        }
        this.logger.debug('identifyUser', { userTag });
        this.payloadData.identifyUser(userTag);
    }
    /**
     * @inheritDoc
     */
    enterAction(actionName) {
        if (this.isShutdown() || this.config.dataCollectionLevel === 0 /* Off */) {
            return NullAction_1.defaultNullAction;
        }
        this.logger.debug('enterAction', { actionName });
        const action = new ActionImpl_1.ActionImpl(actionName, this.payloadData.currentTimestamp(), this, this.payloadData, this.config);
        this.openActions.push(action);
        return action;
    }
    /**
     * @inheritDoc
     */
    reportError(name, code, message) {
        if (this.isShutdown() || this.config.dataCollectionLevel === 0 /* Off */) {
            return;
        }
        if (typeof name !== 'string' || name.length === 0) {
            LoggingUtils_1.validationFailed(this.logger, 'reportError', 'Name must be a non empty string', { name });
            return;
        }
        if (!isFinite(code)) {
            LoggingUtils_1.validationFailed(this.logger, 'reportError', 'Code must be a finite number', { code });
            return;
        }
        this.logger.debug('reportError', { name, code, message });
        this.payloadData.reportError(0, name, code, String(message));
    }
    /**
     * @inheritDoc
     */
    reportCrash(name, message, stacktrace) {
        if (this.isShutdown() || this.config.crashReportingLevel !== 2 /* OptInCrashes */) {
            return;
        }
        if (typeof name !== 'string' || name.length === 0) {
            LoggingUtils_1.validationFailed(this.logger, 'reportCrash', 'name must be a non empty string', { name });
            return;
        }
        this.logger.debug('reportCrash', { name, message, stacktrace });
        this.payloadData.reportCrash(name, String(message), String(stacktrace));
    }
    traceWebRequest(url) {
        if (this.isShutdown() || this.config.dataCollectionLevel === 0 /* Off */) {
            return NullWebRequestTracer_1.defaultNullWebRequestTracer;
        }
        if (typeof url !== 'string' || url.length === 0) {
            LoggingUtils_1.validationFailed(this.logger, 'traceWebRequest', 'url must be a non empty string', { url });
            return NullWebRequestTracer_1.defaultNullWebRequestTracer;
        }
        this.logger.debug('traceWebRequest', { url });
        const { deviceId, applicationId, loggerFactory } = this.config;
        return new WebRequestTracerImpl_1.WebRequestTracerImpl(this.payloadData, 0, url, loggerFactory, deviceId, applicationId, this.sessionId);
    }
    isShutdown() {
        return this._isShutdown === true;
    }
    _getOpenActions() {
        return this.openActions.slice(0);
    }
    _endAction(action) {
        Utils_1.removeElement(this.openActions, action);
    }
}
exports.SessionImpl = SessionImpl;
//# sourceMappingURL=SessionImpl.js.map